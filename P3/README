Weston Lane [wrl24]
Jeremy Ruiz [jr2051]

Test Plan
    In creating our test plan, we first examined the project instructions before any implementation and found that the shell behavior could be split
    up into separate modes and likewise, our testing would need to account for this as well. While interactive Mode was more of a live 
    environment, batch testing provided a more standard case-based analysis of required utility. Because of this potential discrepency in approaches,
    we thought it would be best to split our testing between dynamic, potentially volatile, and actively configurable behavior to the Interactive Mode,
    while maintaining a repeatable list of test programs meant to be supplied to our shell environment through the Batch Mode. In short, we used the
    Interactive Mode to test quick changes for instant feedback, and the batch testing for a suite of foreseeable, specific, and reproducable list
    of working behavior. 
    
    Using this guide, we determined our strategy for Interactive Mode testing would be to:

    (1) Experiment with newly created features rapidly, often, and observe whether they were working properly,
    (2) Test "easily testable" features like Built-in commands and redirections,

    and our strategy for testing Batch Mode would be to:

    (1) Measure exit status, success and failure, processes, arguments, IO, and things that could be measurable over and over
        again between implementations and versions,
    (2) Examine script running and overall batch-exclusive behavior (like omission of welcome messages), 
    (3) Comprehensively and sequentially run down our entire list of criteria.

    In the end however, we spent most of our time with Batch Mode testing. Below is a list of how we designed our test collection, and what
    main aspects it is comprised of:

Test Scripts

    - test.sh is a series of small tests meant to check the basic functionality of all of the main components and requirements of Project 3. The script 
    is meant to be provided to ./mysh in batch mode. The test programs fed into the script are themselves simple, but the script itself ensures the 
    effectiveness of simple programs, input redirection, piping, mutli-ARG files, multi-pipe and multi-redirection, comparison operators, keywords, 
    and otherwise all expected behavior are fully functional.

    - tests2.sh is an auxiliary testing script meant to further test the basic functionality in combination with itself. Where test.sh tests focuses on
    individual functionality, tests2.sh further expands with testing several aspects at once and additionally adding other test options with exit status
    observations, stdin, out, and err behavior, and bad input error handling.

Descriptions of Test Programs
    
    (1) test_ping.c
        Purpose: Simply used to print a message to output. Used to test file redirection (>) and piping (|), and execution.
        Expected Behavior: prints a single, predictable line to STANDARD OUTPUT.

    (2) test_fail.c
        Purpose: Meant to test failure management and handling errors. Prints to stderr so its output doesn't interfere with stdout redirection tests.
        Expected Behavior: This program should always fails. Exits with non-zero.

    (3) test_succeed
        Purpose: Meant to reliably test success management. Prints to stderr so its output doesn't interfere with stdout redirection tests.
        Expected Behavior: This program should always succeed. Exits with status 0.

    (4) test_receive.c
        Purpose: Meant to examine STDIN delivery. Used to test file redirection (<) and piping (|).
        Expected Behavior: reads one line from STANDARD INPUT and prints a message to STANDARD OUTPUT.

    (5) test_receiveArgs.c
        Purpose: Meant to test argument passing and handling. Used to test file redirection (<) and piping (|)
        Expected Behavior: reads one line from STANDARD INPUT and prints a message to STANDARD OUTPUT. 
        
    (6) test_cat.c 
		Purpose: Meant to test multi-line STDIN, redirection (<) and piping (|) for test2 tests.
		Expected Behavior: Repeatedly reads lines until EOF from STANDARD INPUT. Prints to STANDARD OUTPUT.

    (7) test_stdin.c
		Purpose: Meant for testing child processes with STANDARD INPUT and typical Batch Mode characteristics.
		Expected Behavior: reads one line from STANDARD INPUT and prints a message to STANDARD OUTPUT. 
		
    (8) test_status.c 
		Purpose: Used for testing exit codes and conditionals. Allows for a configurable exit code.
		Expected Behavior: Takes an integer to pass for exit code. Prints to STANDARD ERROR with exit status.
		
    (9) test_out_err.c 
		Purpose: Used for examining both STANDARD ERROR and STANDARD OUTPUT behavior.
		Expected Behavior: Prints both to STANDARD ERROR and STANDARD OUTPUT respectively. 

Implementation details:
    -Notes: design does not allow for comments to be inbetween newlines

            design will only check for exit or die as the last command in a pipe, therefore foo | die | bar will ignore die since there is another command to run
            this made sense to me as why would anyone try to run an exit or die in the middle of a job with mutiple commands

    This project is broken into multiple logical pieces. mysh.c is the core application loop. It contains the logic for deciding the mode, parsing each line, and creating the command data structures.

    The CommandData struct has its own intantiation logic where it parses the tokens of the command into an array list of arguements and input and output files
    
    Then the PipeLineExecution.c file is the core logic for forking and handling child processes. Each commands in a job is run and it's logic is determined by it's first argument which is the executable or the file.

Design Notes
    To Run:
    cd P3
    $ make clean
    $ make
    $ ./mysh [args]
    $ (for build and run interactive) - make run
    $ (for build and run batch) - ex. make run ARGS="../TestPrograms/test.sh"